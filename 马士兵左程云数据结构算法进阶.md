# 马士兵左程云数据结构算法进阶

## 1、单调栈和窗口及其更新结构

### 1、窗口内最大值的结构

#### 原理

> 通过双端队列来进行最大值结构的实现
>
> 1、最基本的原则，双端队列从头到尾的数 是从大到小的
>
> 2、当R变化的时候，先看是否能直接加进尾部，如果不能就弹出尾部元素在进行判断(直到尾部元素大于要入队的元素或队列为空)在入队
>
> 3、当L变化的时候，看看队列头的数是不是要过期的坐标，是就弹出，不是就不弹出

**这里的双端队列就是代表谁会成为最大值的优先级（满足值比你大，坐标比你过期的晚)**

#### 代码

```java
   /*
     * @Description:
     * @Author: FULITAO
     * @param: arr,要划过的数组
     * @param: w;窗口的大小
     * @Return: int[]
     * @Date: 2021/10/8 20:55
     **/
    public static int[] getMaxWindow(int[] arr, int w) {
        if (arr == null || w < 1 || arr.length < w) {
            return null;
        }
        //LinkedList底层就是双端队列实现的 在这里放的是数组的下标
        LinkedList<Integer> qMax = new LinkedList<>();
        //这里代表结果的个数 一个窗口的大小和数组的大小就决定了结果的长度
        int[] res = new int[arr.length - w + 1];
        int index = 0;
        for (int r = 0; r < arr.length; r++) {
            //把当前窗口状态的最大值处理一下
            //当双端队列不为空而且双端队列的尾巴的值小于等于当前窗口R要入队的值的时候就弹出
            while (!qMax.isEmpty() && arr[qMax.peekLast()] <= arr[r]) {
                qMax.pollLast();
            }
            //从尾部入队 这里记录的是他的下标值
            qMax.add(r);
            //这个语句代表 窗口的左边已经划出这个队列头部的值就过期掉
            if (qMax.peekFirst() == r - w) {
                qMax.pollFirst();
            }
            //当R滑动到了大于等于窗口宽度的时候就记录当前的最大值情况
            if (r >= w - 1) {
                res[index++] = arr[qMax.peekFirst()];
            }

        }

        return res;
    }
```

### 2、题目：给定一个数组arr和一个数num某个arr的sub，如果想达标必须满足sub中的最大值减去最小值<=num,返回arr中达标数组的个数

#### 思路

> 1、从这个提议可以想到假如使用暴力方法来遍历数组的话会造成时间复杂度很高
>
> 2、采用窗口来进行处理这个题，做一个max来记录当前arr[L....R]的最大值，min记录arr[L...R]上的最小值
>
> 3、我们考虑下当在arr[L...R]上达标，L与R都缩小范围 变为arr[L'...R']是否还达标呢，答案是肯定 因为他在大范围上达标了，他在小范围上的 max和min记录结构，max只可能比他小或者等于 min只可能比他大或者等于。
>
> 4、我们考虑下当在arr[L....R]上不达标,L与R都扩大范围变为arr[L'....R']是否达标呢，答案是否定的因为他在小规模上都不达标了在大规模上的max和min的记录结构max只有可能比他大或者等于 min只有比他小或者等于。
>
> 5、根据以上四点我们就可以知道了这题的解法，我们L从0出发 R依次递增当达到了第一个不达标的点的时候R不变，我们求以L出发到R中满足的的子数组的个数即L...0 L....1  L....2 等等 然后L往右移动一位判断此时是否达标，不达标继续移动达标了就移动R直到来到下次不达标的点

#### 代码

```java
    /*
     * @Description:
     * @Author: FULITAO
     * @param: arr,所提供的的数组
     * @param: num;达标的要求
     * @Return: int
     * @Date: 2021/10/8 21:43
     **/
    public static int subArrValid(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        //最大值的记录结构体
        LinkedList<Integer> qMax = new LinkedList<>();
        //最小值的记录结构体
        LinkedList<Integer> qMin = new LinkedList<>();
        //窗口的两个边界
        int L = 0;
        int R = 0;
        int res = 0;
        while (L < arr.length) {        //从0开始尝试所有的可能性
            while (R < arr.length) { //R是最后一个下标达标的位置的往后一个位置
                //记录最大值以及最小值的操作
                while (!qMin.isEmpty() && qMin.peekLast() >= arr[R]) {
                    qMin.pollLast();
                }
                qMin.add(R);
                while (!qMax.isEmpty() && qMax.peekLast() <= arr[R]) {
                    qMax.pollLast();
                }
                qMax.add(R);
                //当发现R来到的位置已经不满足了 就直接跳出当前循环
                if (arr[qMax.peekFirst()] - arr[qMin.peekFirst()] > num) {
                    break;
                }
                R++;
            }
            //L...R-1位置上是满足num的要求的，求出有多少个个数
            res += (R - 1) - L;
            //L要往右走一个所以要过期这两个记录里面的东西
            if (qMax.peekFirst() == L) {
                qMax.pollFirst();
            }
            if (qMin.peekFirst() == L) {
                qMin.pollFirst();
            }
            L++;
        }
        return res;
    }
```

## 2、单调栈

### 1、解决的问题

> 用于解决求在一个数组中，i位置的数左边比他小的最近的位置在哪和右边比他小的最近的位置在哪
>
> 使用暴力递归的话他的时间复杂度是O(N^2)
>
> 使用单调栈可以变为O(N);

### 2、思路

#### 1、数组没有重复值的情况

> 1、准备一个栈
>
> 2、栈中维护的顺序是从栈底到栈顶都是从小到大的
>
> 3、当遇到一个数，栈为空或者比栈顶元素还要大就直接入栈
>
> 4、遇到一个数比栈顶元素要小就释放栈顶元素，栈顶元素左边最近小于的坐标就是当前数的坐标，右边最近的数就是栈顶元素下面的一个数假如下面没数就是空
>
> 5、遍历完之后单独处理栈中剩下的元素也按第4部的思路来进行处理

#### 代码

```java
    /*
     * @Description:
     * @Author: FULITAO
     * @param: arr;目标数组
     * @Return: int[][]   第一个数组代表的是目标数组的下标，第二数组0位置代表左边的位置 1位置代表右边的位置
     * @Date: 2021/10/11 22:37
     **/
    public static int[][] getNearLessNoRepeat(int[] arr) {
        Stack<Integer> stack = new Stack<>();
        int[][] answear = new int[arr.length][2];
        for (int i = 0; i < arr.length; i++) {
            //当栈中为空 或者栈中的栈顶元素小于当前元素就直接入栈
            if (stack.isEmpty() || arr[stack.peek()] < arr[i]) {
                //栈中存的是下标值
                stack.add(i);
                continue;
            }
            while (!stack.isEmpty()&&arr[stack.peek()] > arr[i]) {
                Integer releaseIndex = stack.pop();
                answear[releaseIndex][1] = i;
                //看看当前要释放的位置下一个位置是否有元素
                int stackNext = stack.isEmpty() ? -1 : stack.peek();
                answear[releaseIndex][0] = stackNext;
            }
            stack.add(i);
        }
        while(!stack.isEmpty()){
            int releaseIndex = stack.pop();
            int stackNext=stack.isEmpty()?-1:stack.peek();
            answear[releaseIndex][1]=-1;
            answear[releaseIndex][0]=stackNext;
        }
        return answear;
    }
```

#### 2、数组有重复值的情况

> 1、总体思路和没重复值相同，但是在栈中压得是一个集合类型
>
> 2、当一个数要释放栈中的数的时候右边还是当前index，左边是他在栈中下面的集合中的最右边的位置

#### 代码

```java
```

